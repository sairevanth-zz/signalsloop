/**
 * Smart Notification Agent (Phase 3)
 *
 * Listens to: spec.auto_drafted, theme.threshold_reached, feedback.voted, sentiment.analyzed
 * Actions: Sends intelligent notifications to PM/team via Slack
 * Triggers: No events (terminal agent)
 *
 * This agent provides real-time awareness of important product signals
 */

import { DomainEvent } from '@/lib/events/types';
import { getServiceRoleClient } from '@/lib/supabase-singleton';
import { checkAndNotifyStakeholders } from '@/lib/stakeholders/interest-tracking';

/**
 * Handle spec.auto_drafted event
 * Notify PM that a spec is ready for review
 */
export async function handleSpecAutoDrafted(event: DomainEvent): Promise<void> {
  const startTime = Date.now();
  const { payload, metadata } = event;

  console.log(`[NOTIFICATION AGENT] üì® Spec auto-drafted: ${payload.title}`);

  try {
    const supabase = getServiceRoleClient();

    // Get project details
    const { data: project } = await supabase
      .from('projects')
      .select('name, slug, owner_id, settings')
      .eq('id', metadata.project_id)
      .single();

    if (!project) {
      console.log('[NOTIFICATION AGENT] ‚è≠Ô∏è  Project not found');
      return;
    }

    // Check if Slack notifications are enabled
    const slackEnabled = project.settings?.notifications?.slack?.enabled;
    if (!slackEnabled) {
      console.log('[NOTIFICATION AGENT] ‚è≠Ô∏è  Slack notifications disabled for project');
      return;
    }

    // Get project owner info
    const { data: owner } = await supabase
      .from('users')
      .select('email, name')
      .eq('id', project.owner_id)
      .single();

    const specUrl = `/${project.slug}/specs/${event.aggregate_id}`;
    const feedbackCount = payload.linked_feedback_count || 0;

    // Prepare notification message
    const message = {
      channel: project.settings?.notifications?.slack?.channel || '#product',
      text: `üìù *New Spec Ready for Review*`,
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'üìù Spec Auto-Drafted',
          },
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${payload.title}*\n\nA new product spec has been automatically drafted based on ${feedbackCount} user requests.`,
          },
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*Project:*\n${project.name}`,
            },
            {
              type: 'mrkdwn',
              text: `*Feedback Items:*\n${feedbackCount}`,
            },
            {
              type: 'mrkdwn',
              text: `*Status:*\n‚è≥ Draft (needs review)`,
            },
            {
              type: 'mrkdwn',
              text: `*Assigned to:*\n${owner?.name || owner?.email || 'PM'}`,
            },
          ],
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'üìñ Review Spec',
              },
              url: `${process.env.NEXT_PUBLIC_APP_URL || 'https://signalsloop.com'}${specUrl}`,
              style: 'primary',
            },
          ],
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `ü§ñ Auto-generated by SignalsLoop AI ‚Ä¢ <${process.env.NEXT_PUBLIC_APP_URL || 'https://signalsloop.com'}${specUrl}|View Spec>`,
            },
          ],
        },
      ],
    };

    // Send Slack notification
    await sendSlackNotification(project.settings?.notifications?.slack?.webhook_url, message);

    const duration = Date.now() - startTime;
    console.log(`[NOTIFICATION AGENT] ‚úÖ Notification sent in ${duration}ms`);
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[NOTIFICATION AGENT] ‚ùå Error after ${duration}ms:`, error);
  }
}

/**
 * Handle theme.threshold_reached event
 * Notify PM that a theme has high demand and needs attention
 */
export async function handleThemeThresholdReached(event: DomainEvent): Promise<void> {
  const startTime = Date.now();
  const { payload, metadata } = event;

  console.log(`[NOTIFICATION AGENT] üì® Theme threshold: ${payload.theme_name} (${payload.frequency} requests)`);

  try {
    const supabase = getServiceRoleClient();

    // Get project details
    const { data: project } = await supabase
      .from('projects')
      .select('name, slug, settings')
      .eq('id', metadata.project_id)
      .single();

    if (!project || !project.settings?.notifications?.slack?.enabled) {
      console.log('[NOTIFICATION AGENT] ‚è≠Ô∏è  Slack notifications disabled');
      return;
    }

    const sentiment = payload.avg_sentiment || 0;
    const sentimentEmoji = sentiment > 0.3 ? 'üòä' : sentiment < -0.3 ? 'üòû' : 'üòê';
    const urgencyLevel = payload.frequency >= 50 ? 'high' : payload.frequency >= 30 ? 'medium' : 'normal';

    const message = {
      channel: project.settings?.notifications?.slack?.channel || '#product',
      text: `üî• High-demand feature request: ${payload.theme_name}`,
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: 'üî• High-Demand Feature Alert',
          },
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${payload.theme_name}*\n\n${payload.description || 'Users are requesting this feature'}`,
          },
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*Requests:*\n${payload.frequency} users`,
            },
            {
              type: 'mrkdwn',
              text: `*Sentiment:*\n${sentimentEmoji} ${sentiment > 0 ? 'Positive' : sentiment < 0 ? 'Negative' : 'Neutral'}`,
            },
            {
              type: 'mrkdwn',
              text: `*Urgency:*\n${urgencyLevel === 'high' ? 'üî¥ High' : urgencyLevel === 'medium' ? 'üü° Medium' : 'üü¢ Normal'}`,
            },
          ],
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `üí° A spec will be auto-drafted for this theme shortly`,
            },
          ],
        },
      ],
    };

    await sendSlackNotification(project.settings?.notifications?.slack?.webhook_url, message);

    const duration = Date.now() - startTime;
    console.log(`[NOTIFICATION AGENT] ‚úÖ Theme alert sent in ${duration}ms`);
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[NOTIFICATION AGENT] ‚ùå Error after ${duration}ms:`, error);
  }
}

/**
 * Handle high-vote feedback
 * Notify when feedback gets significant upvotes
 */
export async function handleHighVoteFeedback(event: DomainEvent): Promise<void> {
  const { payload } = event;

  // Only notify on high vote counts
  if (payload.vote_count < 10) {
    return;
  }

  const startTime = Date.now();
  console.log(`[NOTIFICATION AGENT] üì® High-vote feedback: ${payload.vote_count} votes`);

  try {
    const supabase = getServiceRoleClient();

    // Get full post details
    const { data: post } = await supabase
      .from('posts')
      .select('id, title, content, category, project_id')
      .eq('id', event.aggregate_id)
      .single();

    if (!post) return;

    // Get project details
    const { data: project } = await supabase
      .from('projects')
      .select('name, slug, settings')
      .eq('id', post.project_id)
      .single();

    if (!project || !project.settings?.notifications?.slack?.enabled) {
      return;
    }

    const postUrl = `/${project.slug}/feedback/${post.id}`;

    const message = {
      channel: project.settings?.notifications?.slack?.channel || '#product',
      text: `‚¨ÜÔ∏è Trending: ${post.title} (${payload.vote_count} votes)`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `‚¨ÜÔ∏è *Trending Feedback*\n\n*${post.title}*\n\n${payload.vote_count} users voted for this`,
          },
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'View Feedback',
              },
              url: `${process.env.NEXT_PUBLIC_APP_URL || 'https://signalsloop.com'}${postUrl}`,
            },
          ],
        },
      ],
    };

    await sendSlackNotification(project.settings?.notifications?.slack?.webhook_url, message);

    const duration = Date.now() - startTime;
    console.log(`[NOTIFICATION AGENT] ‚úÖ High-vote alert sent in ${duration}ms`);
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[NOTIFICATION AGENT] ‚ùå Error:`, error);
  }
}

/**
 * Send Slack notification
 * Helper function to send formatted messages to Slack
 */
async function sendSlackNotification(webhookUrl: string | undefined, message: any): Promise<void> {
  if (!webhookUrl) {
    console.log('[NOTIFICATION AGENT] ‚è≠Ô∏è  No Slack webhook URL configured');
    return;
  }

  try {
    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(message),
    });

    if (!response.ok) {
      throw new Error(`Slack API error: ${response.status}`);
    }

    console.log('[NOTIFICATION AGENT] ‚úÖ Slack notification sent');
  } catch (error) {
    console.error('[NOTIFICATION AGENT] ‚ùå Failed to send Slack notification:', error);
    // Don't throw - notification failure shouldn't crash the agent
  }
}

/**
 * Send email notification (future enhancement)
 * Currently logs to console, can be integrated with email service
 */
export async function sendEmailNotification(to: string, subject: string, body: string): Promise<void> {
  console.log('[NOTIFICATION AGENT] üìß Email notification:', { to, subject });
  // TODO: Integrate with email service (SendGrid, Resend, etc.)
  // await emailService.send({ to, subject, html: body });
}

/**
 * Handle generic event for stakeholder notifications
 * Checks if any stakeholders are interested in this event and notifies them
 */
export async function handleStakeholderNotification(event: DomainEvent): Promise<void> {
  const startTime = Date.now();
  console.log(`[NOTIFICATION AGENT] üë• Checking stakeholder interests for: ${event.type}`);

  try {
    await checkAndNotifyStakeholders(
      event.metadata.project_id,
      event.type,
      event.payload
    );

    const duration = Date.now() - startTime;
    console.log(`[NOTIFICATION AGENT] ‚úÖ Stakeholder check complete in ${duration}ms`);
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[NOTIFICATION AGENT] ‚ùå Error checking stakeholders after ${duration}ms:`, error);
  }
}
