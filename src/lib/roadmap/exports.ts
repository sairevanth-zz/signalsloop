/**
 * Roadmap Export Generation
 *
 * Generates exportable roadmap documents in multiple formats:
 * - Markdown: For GitHub, Notion, etc.
 * - PDF: For stakeholder presentations
 *
 * Exports include:
 * - Executive summary
 * - Prioritized recommendations with AI reasoning
 * - Priority matrix visualization (text-based)
 * - Filtering by priority levels
 */

import { getSupabaseServiceRoleClient } from '@/lib/supabase-client';
import puppeteer from 'puppeteer-core';

// =====================================================
// TYPES
// =====================================================

export interface ExportFilters {
  priorities?: string[];
  minScore?: number;
  maxCount?: number;
  includeReasoning?: boolean;
}

interface RoadmapSuggestion {
  id: string;
  priority_score: number;
  priority_level: string;
  reasoning_text?: string;
  why_matters?: string;
  business_impact_text?: string;
  implementation_strategy?: string;
  recommendation_text?: string;
  frequency_score: number;
  sentiment_score: number;
  business_impact_score: number;
  effort_score: number;
  competitive_score: number;
  themes: {
    theme_name: string;
    frequency: number;
    avg_sentiment: number;
    first_seen: string;
  };
}

// =====================================================
// PRIORITY EMOJIS & FORMATTING
// =====================================================

const PRIORITY_EMOJIS: Record<string, string> = {
  critical: 'üî¥',
  high: 'üü†',
  medium: 'üü°',
  low: 'üîµ'
};

const PRIORITY_LABELS: Record<string, string> = {
  critical: 'P0 - Critical',
  high: 'P1 - High',
  medium: 'P2 - Medium',
  low: 'P3 - Low'
};

// =====================================================
// MARKDOWN GENERATION
// =====================================================

/**
 * Generate a comprehensive Markdown roadmap export
 */
export async function generateMarkdownExport(
  projectId: string,
  filters: ExportFilters = {}
): Promise<string> {
  const supabase = getSupabaseServiceRoleClient();

  if (!supabase) {
    throw new Error('Failed to initialize Supabase client');
  }

  // Fetch project details
  const { data: project } = await supabase
    .from('projects')
    .select('name')
    .eq('id', projectId)
    .single();

  const projectName = project?.name || 'Unknown Project';

  // Build query with filters
  let query = supabase
    .from('roadmap_suggestions')
    .select(`
      *,
      themes (
        theme_name,
        frequency,
        avg_sentiment,
        first_seen
      )
    `)
    .eq('project_id', projectId)
    .order('priority_score', { ascending: false });

  if (filters.priorities && filters.priorities.length > 0) {
    query = query.in('priority_level', filters.priorities);
  }

  if (filters.minScore !== undefined) {
    query = query.gte('priority_score', filters.minScore);
  }

  if (filters.maxCount) {
    query = query.limit(filters.maxCount);
  }

  const { data: suggestions, error } = await query;

  if (error) {
    throw new Error(`Error fetching suggestions: ${error.message}`);
  }

  if (!suggestions || suggestions.length === 0) {
    return '# No roadmap suggestions found\n\nTry generating roadmap suggestions first.';
  }

  // Build markdown content
  let markdown = buildMarkdownHeader(projectName, suggestions);
  markdown += buildExecutiveSummary(suggestions);
  markdown += buildPrioritizedRecommendations(suggestions, filters.includeReasoning);
  markdown += buildPriorityMatrix(suggestions);
  markdown += buildScoringMethodology();

  return markdown;
}

function buildMarkdownHeader(projectName: string, suggestions: RoadmapSuggestion[]): string {
  return `# ${projectName} - Product Roadmap

**Generated by SignalsLoop AI**
**Based on User Feedback Analysis**
**Date:** ${new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })}

---

`;
}

function buildExecutiveSummary(suggestions: RoadmapSuggestion[]): string {
  const priorityCounts = {
    critical: suggestions.filter(s => s.priority_level === 'critical').length,
    high: suggestions.filter(s => s.priority_level === 'high').length,
    medium: suggestions.filter(s => s.priority_level === 'medium').length,
    low: suggestions.filter(s => s.priority_level === 'low').length
  };

  const totalMentions = suggestions.reduce(
    (sum, s) => sum + (s.themes?.frequency || 0),
    0
  );

  const avgScore = suggestions.reduce(
    (sum, s) => sum + Number(s.priority_score),
    0
  ) / suggestions.length;

  return `## üìä Executive Summary

**Total Themes Analyzed:** ${suggestions.length}
**Total User Mentions:** ${totalMentions.toLocaleString()}
**Average Priority Score:** ${avgScore.toFixed(1)}/100

### Priority Distribution

- ${PRIORITY_EMOJIS.critical} **Critical (P0):** ${priorityCounts.critical} theme${priorityCounts.critical !== 1 ? 's' : ''} - Immediate action required
- ${PRIORITY_EMOJIS.high} **High (P1):** ${priorityCounts.high} theme${priorityCounts.high !== 1 ? 's' : ''} - Build next quarter
- ${PRIORITY_EMOJIS.medium} **Medium (P2):** ${priorityCounts.medium} theme${priorityCounts.medium !== 1 ? 's' : ''} - Consider for future sprints
- ${PRIORITY_EMOJIS.low} **Low (P3):** ${priorityCounts.low} theme${priorityCounts.low !== 1 ? 's' : ''} - Nice to have

---

`;
}

function buildPrioritizedRecommendations(
  suggestions: RoadmapSuggestion[],
  includeReasoning: boolean = true
): string {
  let markdown = `## üéØ Prioritized Recommendations

`;

  suggestions.forEach((suggestion, index) => {
    const emoji = PRIORITY_EMOJIS[suggestion.priority_level] || '‚ö™';
    const label = PRIORITY_LABELS[suggestion.priority_level] || 'Unknown';
    const themeName = suggestion.themes?.theme_name || 'Unknown Theme';
    const mentions = suggestion.themes?.frequency || 0;
    const sentiment = suggestion.themes?.avg_sentiment || 0;

    markdown += `### ${index + 1}. ${emoji} ${themeName}

**Priority:** ${label} (Score: ${Number(suggestion.priority_score).toFixed(1)}/100)
**User Mentions:** ${mentions}
**Sentiment:** ${formatSentiment(sentiment)}

`;

    // Add scoring breakdown
    markdown += buildScoringBreakdown(suggestion);

    // Add AI reasoning if available and requested
    if (includeReasoning && suggestion.reasoning_text) {
      markdown += `\n#### üí° Strategic Analysis\n\n`;

      if (suggestion.why_matters) {
        markdown += `**Why This Matters Now:**\n${suggestion.why_matters}\n\n`;
      }

      if (suggestion.business_impact_text) {
        markdown += `**Business Impact:**\n${suggestion.business_impact_text}\n\n`;
      }

      if (suggestion.implementation_strategy) {
        markdown += `**Implementation Strategy:**\n${suggestion.implementation_strategy}\n\n`;
      }

      if (suggestion.recommendation_text) {
        markdown += `**Recommendation:**\n${suggestion.recommendation_text}\n\n`;
      }
    }

    markdown += `---\n\n`;
  });

  return markdown;
}

function buildScoringBreakdown(suggestion: RoadmapSuggestion): string {
  const scores = {
    'Frequency': Number(suggestion.frequency_score) * 100,
    'Sentiment': Number(suggestion.sentiment_score) * 100,
    'Business Impact': Number(suggestion.business_impact_score) * 100,
    'Effort': Number(suggestion.effort_score) * 100,
    'Competitive': Number(suggestion.competitive_score) * 100
  };

  let markdown = `**Scoring Breakdown:**\n`;
  markdown += '```\n';

  Object.entries(scores).forEach(([factor, score]) => {
    const bars = Math.round(score / 10);
    const bar = '‚ñà'.repeat(bars) + '‚ñë'.repeat(10 - bars);
    markdown += `${factor.padEnd(20)} ${bar} ${score.toFixed(0)}%\n`;
  });

  markdown += '```\n';

  return markdown;
}

function buildPriorityMatrix(suggestions: RoadmapSuggestion[]): string {
  // Group by impact (priority score) and effort
  const quickWins = suggestions.filter(
    s => Number(s.priority_score) >= 60 && Number(s.effort_score) >= 0.5
  ).slice(0, 5);

  const bigBets = suggestions.filter(
    s => Number(s.priority_score) >= 60 && Number(s.effort_score) < 0.5
  ).slice(0, 5);

  const fillIns = suggestions.filter(
    s => Number(s.priority_score) < 60 && Number(s.effort_score) >= 0.5
  ).slice(0, 5);

  const lowPriority = suggestions.filter(
    s => Number(s.priority_score) < 60 && Number(s.effort_score) < 0.5
  ).slice(0, 5);

  return `## üìä Priority Matrix

This matrix helps visualize the trade-off between impact and effort:

\`\`\`
     High Impact
          ‚Üë
          ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ BIG ‚îÇQUICK‚îÇ
    ‚îÇBETS ‚îÇWINS ‚îÇ ‚Üí Quick Wins (High Impact, Low Effort)
    ‚îÇ     ‚îÇ  ‚úÖ ‚îÇ    DO FIRST
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ LOW ‚îÇFILL ‚îÇ
    ‚îÇPRI  ‚îÇINS  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
     Low Effort ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí High Effort
\`\`\`

### ‚úÖ Quick Wins (High Impact, Low Effort) - DO FIRST
${formatMatrixItems(quickWins)}

### ‚ö° Big Bets (High Impact, High Effort) - DO NEXT
${formatMatrixItems(bigBets)}

### üîß Fill-Ins (Low Impact, Low Effort) - DO WHEN IDLE
${formatMatrixItems(fillIns)}

### ‚è∏Ô∏è Low Priority (Low Impact, High Effort) - DEFER
${formatMatrixItems(lowPriority)}

---

`;
}

function formatMatrixItems(items: RoadmapSuggestion[]): string {
  if (items.length === 0) {
    return '_None_\n';
  }

  return items.map((item, i) => {
    const themeName = item.themes?.theme_name || 'Unknown';
    const score = Number(item.priority_score).toFixed(0);
    return `${i + 1}. **${themeName}** (${score}/100)`;
  }).join('\n') + '\n';
}

function buildScoringMethodology(): string {
  return `## üìê Scoring Methodology

This roadmap was generated using a multi-factor AI scoring algorithm:

### Scoring Factors (Weighted)

1. **Frequency (30%)** - How many users are requesting this feature
2. **Sentiment (25%)** - User frustration level (negative sentiment = higher priority)
3. **Business Impact (25%)** - Revenue impact, churn risk, urgency signals
4. **Effort (10%)** - Lower effort = higher score (prioritize quick wins)
5. **Competitive (10%)** - How many competitors have this feature

### Priority Levels

- **üî¥ Critical (P0):** Score ‚â• 75 - Immediate action required
- **üü† High (P1):** Score ‚â• 60 - Build in next quarter
- **üü° Medium (P2):** Score ‚â• 40 - Consider for future sprints
- **üîµ Low (P3):** Score < 40 - Nice to have

### Data Sources

This analysis is based on feedback collected from:
- Reddit discussions
- Twitter mentions
- G2 reviews
- Support tickets
- Hacker News threads
- Product Hunt comments

---

*Generated by SignalsLoop - AI-Powered Product Intelligence*
`;
}

function formatSentiment(sentiment: number): string {
  if (sentiment <= -0.5) return `${sentiment.toFixed(2)} (Very Negative üò°)`;
  if (sentiment <= -0.2) return `${sentiment.toFixed(2)} (Negative üòü)`;
  if (sentiment <= 0.2) return `${sentiment.toFixed(2)} (Neutral üòê)`;
  if (sentiment <= 0.5) return `${sentiment.toFixed(2)} (Positive üôÇ)`;
  return `${sentiment.toFixed(2)} (Very Positive üòä)`;
}

// =====================================================
// PDF GENERATION
// =====================================================

/**
 * Generate a styled PDF export from Markdown
 */
export async function generatePDFExport(
  projectId: string,
  filters: ExportFilters = {}
): Promise<Buffer> {
  // First generate markdown
  const markdown = await generateMarkdownExport(projectId, filters);

  // Convert markdown to HTML (simple conversion - in production use a proper markdown parser)
  const html = convertMarkdownToHTML(markdown);

  // Wrap in styled HTML template
  const styledHtml = wrapInHTMLTemplate(html);

  // Generate PDF using Puppeteer
  let browser;

  try {
    browser = await puppeteer.launch({
      headless: true,
      executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser',
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu'
      ]
    });

    const page = await browser.newPage();
    await page.setContent(styledHtml, { waitUntil: 'networkidle0' });

    const pdf = await page.pdf({
      format: 'A4',
      margin: {
        top: '20mm',
        right: '20mm',
        bottom: '20mm',
        left: '20mm'
      },
      printBackground: true
    });

    await browser.close();

    return Buffer.from(pdf);

  } catch (error) {
    if (browser) {
      await browser.close();
    }
    throw error;
  }
}

function convertMarkdownToHTML(markdown: string): string {
  // Basic markdown to HTML conversion
  // In production, use a proper library like marked or remark
  let html = markdown
    // Headers
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    // Bold
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    // Code blocks
    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
    // Horizontal rules
    .replace(/^---$/gim, '<hr>')
    // Line breaks
    .replace(/\n\n/g, '</p><p>')
    // Lists
    .replace(/^- (.+)$/gim, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');

  return `<p>${html}</p>`;
}

function wrapInHTMLTemplate(content: string): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #fff;
    }

    h1 {
      color: #1a1a1a;
      border-bottom: 3px solid #2563eb;
      padding-bottom: 10px;
      margin-top: 0;
      font-size: 28px;
    }

    h2 {
      color: #2563eb;
      margin-top: 40px;
      margin-bottom: 15px;
      font-size: 22px;
    }

    h3 {
      color: #3b82f6;
      margin-top: 25px;
      margin-bottom: 10px;
      font-size: 18px;
    }

    p {
      margin: 10px 0;
    }

    strong {
      color: #1a1a1a;
      font-weight: 600;
    }

    code, pre {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }

    pre {
      padding: 15px;
      overflow-x: auto;
      border-left: 3px solid #2563eb;
    }

    pre code {
      background: none;
      padding: 0;
    }

    hr {
      border: none;
      border-top: 1px solid #e5e7eb;
      margin: 30px 0;
    }

    ul {
      margin: 10px 0;
      padding-left: 25px;
    }

    li {
      margin: 5px 0;
    }

    .page-break {
      page-break-after: always;
    }
  </style>
</head>
<body>
  ${content}
</body>
</html>
`;
}

// =====================================================
// EXPORT PERSISTENCE
// =====================================================

/**
 * Save export metadata to database
 */
export async function saveExportMetadata(
  projectId: string,
  userId: string,
  exportType: 'markdown' | 'pdf',
  filePath: string,
  filters: ExportFilters
): Promise<string> {
  const supabase = getSupabaseServiceRoleClient();

  if (!supabase) {
    throw new Error('Failed to initialize Supabase client');
  }

  const { data, error } = await supabase
    .from('roadmap_exports')
    .insert({
      project_id: projectId,
      user_id: userId,
      export_type: exportType,
      file_path: filePath,
      included_priorities: filters.priorities || ['critical', 'high', 'medium', 'low'],
      filter_config: filters
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Error saving export metadata: ${error.message}`);
  }

  return data.id;
}

/**
 * Increment download count for an export
 */
export async function incrementDownloadCount(exportId: string): Promise<void> {
  const supabase = getSupabaseServiceRoleClient();

  if (!supabase) {
    throw new Error('Failed to initialize Supabase client');
  }

  await supabase.rpc('increment_download_count', { export_id: exportId });
}
